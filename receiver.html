<!DOCTYPE html>
<html>
<head>
    <title>TXQR Receiver</title>
    <script src="https://cdn.jsdelivr.net/npm/jsqr/dist/jsQR.js"></script>
    <style>
        body { font-family: sans-serif; text-align: center; padding: 20px; }
        video, canvas { display: block; margin: 0 auto; }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        h1, #status {
        }

        #video {
            flex: 1;
            overflow: auto;
        }

        /* è¿›åº¦ä¿¡æ¯æ ·å¼ */
        .progress-container {
            margin: 15px auto;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
            max-width: 400px;
        }

        .file-info {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        .file-name {
            font-weight: bold;
            color: #333;
            word-break: break-all;
        }

        .progress-bar-container {
            background: #ddd;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-text {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }

        .progress-detail {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .speed-info {
            font-size: 13px;
            color: #4CAF50;
            font-weight: bold;
            margin-top: 5px;
        }

        .complete {
            background: linear-gradient(90deg, #2196F3, #03A9F4);
        }
    </style>
</head>
<body>
<h1>TXQR Receiver</h1>
<video id="video" width="100%" height="400" autoplay muted playsinline></video>
<canvas id="canvas" width="640" height="640" style="display:none;"></canvas>

<div class="progress-container">
    <div class="file-info">
        ğŸ“ æ–‡ä»¶: <span class="file-name" id="fileName">ç­‰å¾…æ¥æ”¶...</span>
    </div>
    <div class="progress-bar-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    <div class="progress-text" id="progressText">0%</div>
    <div class="progress-detail" id="progressDetail">å·²æ¥æ”¶: 0 / 0 å— | 0 B</div>
    <div class="speed-info" id="speedInfo">âš¡ é€Ÿç‡: -- KB/s</div>
</div>

<p id="status">Waiting for QR codes...</p>

<script>
    // === å·²è§£ç çš„å— ===
    let decodedChunks = {};       // ç´¢å¼• -> Uint8Array (å·²ç¡®è®¤è§£ç çš„å•å—æ•°æ®)
    let pendingFrames = [];       // å¾…è§£ç çš„ XOR æ··åˆå¸§ [{indices: [], chunk: Uint8Array}]
    let pendingIndexMap = {};     // ç´¢å¼• -> Set<pendingFrameç´¢å¼•> çš„æ˜ å°„ï¼ŒåŠ é€ŸæŸ¥æ‰¾
    let processedFrameHashes = new Set(); // å·²å¤„ç†å¸§çš„å“ˆå¸Œé›†åˆï¼Œç”¨äºå»é‡
    let totalChunks = 0;
    let fileSize = 0;
    let fileName = "";            // ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºå°šæœªæ”¶åˆ°æ–‡ä»¶å
    let receivedMeta = false;     // æ˜¯å¦å·²æ”¶åˆ° META å¸§
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');

    // é€Ÿç‡ç»Ÿè®¡
    let startTime = null;
    let lastSpeedUpdate = 0;
    let lastDecodedCount = 0;

    // Base45 è§£ç è¡¨
    const BASE45_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
    const BASE45_MAP = {};
    for (let i = 0; i < BASE45_CHARS.length; i++) {
        BASE45_MAP[BASE45_CHARS[i]] = i;
    }

    function decodeBase45(str) {
        let result = [];
        for (let i = 0; i < str.length; i += 3) {
            if (i + 2 < str.length) {
                let c = BASE45_MAP[str[i]];
                let d = BASE45_MAP[str[i + 1]];
                let e = BASE45_MAP[str[i + 2]];
                let x = c * 45 * 45 + d * 45 + e;
                result.push(x >> 8);
                result.push(x & 0xff);
            } else if (i + 1 < str.length) {
                let c = BASE45_MAP[str[i]];
                let d = BASE45_MAP[str[i + 1]];
                let x = c * 45 + d;
                result.push(x);
            }
        }
        return new Uint8Array(result);
    }

    // è¯·æ±‚é«˜åˆ†è¾¨ç‡æ‘„åƒå¤´
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        document.getElementById('status').textContent = "é”™è¯¯ï¼šæµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ï¼Œè¯·ä½¿ç”¨ HTTPS è®¿é—®";
    } else {
        navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: "environment",
                width: { ideal: 4096 },
                height: { ideal: 2160 }
            }
        })
            .then(stream => video.srcObject = stream)
            .catch(err => {
                console.error(err);
                document.getElementById('status').textContent = "æ‘„åƒå¤´é”™è¯¯: " + err.message;
            });
    }

    function formatSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    function updateProgress() {
        let received = Object.keys(decodedChunks).length;
        let percentage = totalChunks > 0 ? Math.round((received / totalChunks) * 100) : 0;
        let receivedSize = 0;
        Object.values(decodedChunks).forEach(chunk => {
            receivedSize += chunk.byteLength;
        });

        document.getElementById('progressBar').style.width = percentage + '%';
        document.getElementById('progressText').textContent = percentage + '%';
        document.getElementById('progressDetail').textContent =
            `å·²æ¥æ”¶: ${received} / ${totalChunks} å— | ${formatSize(receivedSize)} / ${formatSize(fileSize)}`;

        // è®¡ç®—ä¼ è¾“é€Ÿç‡
        let now = Date.now();
        if (startTime && now - lastSpeedUpdate > 500) {
            let elapsed = (now - startTime) / 1000;
            let speed = receivedSize / elapsed;
            document.getElementById('speedInfo').textContent =
                `âš¡ é€Ÿç‡: ${(speed / 1024).toFixed(1)} KB/s | å·²ç”¨æ—¶: ${elapsed.toFixed(1)}s`;
            lastSpeedUpdate = now;
        }

        if (percentage >= 100) {
            document.getElementById('progressBar').classList.add('complete');
            let elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            document.getElementById('progressText').textContent = 'âœ… æ¥æ”¶å®Œæˆ!';
            document.getElementById('speedInfo').textContent =
                `âš¡ æ€»ç”¨æ—¶: ${elapsed}s | å¹³å‡é€Ÿç‡: ${(receivedSize / 1024 / (elapsed)).toFixed(1)} KB/s`;
        }
    }

    function decodeMetaFrame(data) {
        // æ ¼å¼: META|total|size|filename
        let parts = data.split("|");
        if (parts.length >= 4 && parts[0] === "META") {
            totalChunks = parseInt(parts[1]);
            fileSize = parseInt(parts[2]);
            fileName = decodeURIComponent(parts[3]);
            receivedMeta = true;
            document.getElementById('fileName').textContent = fileName;
            updateProgress();
            return true;
        }
        return false;
    }

    // === XOR å·¥å…·å‡½æ•° ===
    function xorArrays(a, b) {
        let len = Math.max(a.length, b.length);
        let result = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            result[i] = (a[i] || 0) ^ (b[i] || 0);
        }
        return result;
    }

    // === å¸§å“ˆå¸Œå‡½æ•°ï¼šç”Ÿæˆç´¢å¼•ç»„åˆçš„å”¯ä¸€æ ‡è¯† ===
    function getFrameHash(indices) {
        // æ’åºåæ‹¼æ¥ï¼Œç¡®ä¿ç›¸åŒç´¢å¼•ç»„åˆäº§ç”Ÿç›¸åŒå“ˆå¸Œ
        return indices.slice().sort((a, b) => a - b).join(',');
    }

    // === æ·»åŠ  pendingFrame åˆ°ç´¢å¼•æ˜ å°„ ===
    function addToPendingIndexMap(indices, frameIdx) {
        for (let idx of indices) {
            if (!pendingIndexMap[idx]) {
                pendingIndexMap[idx] = new Set();
            }
            pendingIndexMap[idx].add(frameIdx);
        }
    }

    // === ä»ç´¢å¼•æ˜ å°„ä¸­ç§»é™¤ pendingFrame ===
    function removeFromPendingIndexMap(indices, frameIdx) {
        for (let idx of indices) {
            if (pendingIndexMap[idx]) {
                pendingIndexMap[idx].delete(frameIdx);
                if (pendingIndexMap[idx].size === 0) {
                    delete pendingIndexMap[idx];
                }
            }
        }
    }

    // === Fountain ç åœ¨çº¿è§£ç  ===
    // å½“æ”¶åˆ°ä¸€ä¸ªå¸§æ—¶ï¼š
    //   1. ç”¨å·²çŸ¥çš„ decodedChunks æ¶ˆå…ƒ
    //   2. å¦‚æœæ¶ˆå…ƒååªå‰© 1 ä¸ªæœªçŸ¥ç´¢å¼• â†’ è§£ç æˆåŠŸï¼Œå­˜å…¥ decodedChunks
    //   3. æ¯æ¬¡æ–°è§£ç ä¸€ä¸ªå—åï¼Œå›æº¯æ‰€æœ‰ pendingFrames å°è¯•è¿›ä¸€æ­¥æ¶ˆå…ƒ
    function tryResolveFrame(frame) {
        let { indices, chunk } = frame;
        let data = new Uint8Array(chunk);

        // ç”¨å·²çŸ¥å—æ¶ˆå…ƒ
        let unknowns = [];
        for (let idx of indices) {
            if (decodedChunks[idx]) {
                data = xorArrays(data, decodedChunks[idx]);
            } else {
                unknowns.push(idx);
            }
        }

        if (unknowns.length === 0) {
            // æ‰€æœ‰å—å·²çŸ¥ï¼Œè¿™ä¸ªå¸§æ˜¯å†—ä½™çš„
            return null;
        } else if (unknowns.length === 1) {
            // åªå‰©ä¸€ä¸ªæœªçŸ¥å— â†’ è§£ç æˆåŠŸï¼
            return { index: unknowns[0], data: data };
        } else {
            // å¤šä¸ªæœªçŸ¥å—ï¼Œæš‚å­˜å¾…åç»­æ¶ˆå…ƒ
            return { pending: true, indices: unknowns, chunk: data };
        }
    }

    function processNewChunk(index, data) {
        if (decodedChunks[index]) return; // å·²æœ‰

        decodedChunks[index] = data;
        if (!startTime) startTime = Date.now();

        // ä½¿ç”¨ç´¢å¼•æ˜ å°„ï¼Œåªå¤„ç†åŒ…å«å½“å‰è§£ç å—çš„ pendingFrames
        // é‡‡ç”¨é˜Ÿåˆ—æ–¹å¼å¤„ç†æ–°è§£ç çš„å—
        let newlyDecoded = [{ index, data }];
        
        while (newlyDecoded.length > 0) {
            let { index: currentIdx } = newlyDecoded.shift();
            
            // è·å–æ‰€æœ‰åŒ…å«å½“å‰ç´¢å¼•çš„ pendingFrame ç´¢å¼•
            let relatedFrameIdxs = pendingIndexMap[currentIdx];
            if (!relatedFrameIdxs) continue;
            
            // æ”¶é›†éœ€è¦å¤„ç†çš„å¸§
            let framesToProcess = [];
            for (let frameIdx of relatedFrameIdxs) {
                if (pendingFrames[frameIdx]) {
                    framesToProcess.push({ frameIdx, frame: pendingFrames[frameIdx] });
                }
            }
            
            // æ¸…ç©ºå½“å‰ç´¢å¼•çš„æ˜ å°„ï¼ˆè¿™äº›å¸§å°†è¢«å¤„ç†ï¼‰
            delete pendingIndexMap[currentIdx];
            
            for (let { frameIdx, frame } of framesToProcess) {
                // ä»æ‰€æœ‰ç›¸å…³ç´¢å¼•æ˜ å°„ä¸­ç§»é™¤è¯¥å¸§
                removeFromPendingIndexMap(frame.indices, frameIdx);
                
                let result = tryResolveFrame(frame);
                
                if (result === null) {
                    // å†—ä½™å¸§ï¼Œä¸¢å¼ƒ
                    pendingFrames[frameIdx] = null;
                } else if (result.pending) {
                    // ä»æœ‰å¤šä¸ªæœªçŸ¥ï¼Œæ›´æ–°å¸§å¹¶é‡æ–°æ·»åŠ åˆ°æ˜ å°„
                    let newFrame = { indices: result.indices, chunk: result.chunk };
                    pendingFrames[frameIdx] = newFrame;
                    addToPendingIndexMap(result.indices, frameIdx);
                } else {
                    // è§£ç å‡ºä¸€ä¸ªæ–°å—ï¼
                    pendingFrames[frameIdx] = null;
                    if (!decodedChunks[result.index]) {
                        decodedChunks[result.index] = result.data;
                        newlyDecoded.push({ index: result.index, data: result.data });
                    }
                }
            }
        }
        
        // æ¸…ç† pendingFrames ä¸­çš„ç©ºä½ï¼ˆæƒ°æ€§æ¸…ç†ï¼Œé¿å…é¢‘ç¹æ•°ç»„é‡å»ºï¼‰
        if (pendingFrames.length > 200) {
            let nonNullCount = pendingFrames.filter(f => f !== null).length;
            if (nonNullCount < pendingFrames.length / 2) {
                pendingFrames = pendingFrames.filter(f => f !== null);
                // é‡å»ºç´¢å¼•æ˜ å°„
                pendingIndexMap = {};
                for (let i = 0; i < pendingFrames.length; i++) {
                    if (pendingFrames[i]) {
                        addToPendingIndexMap(pendingFrames[i].indices, i);
                    }
                }
            }
        }
    }

    function decodeFountainChunk(data) {
        try {
            // æ£€æŸ¥æ˜¯å¦æ˜¯å…ƒä¿¡æ¯å¸§
            if (data.startsWith("META|")) {
                decodeMetaFrame(data);
                return false;
            }

            // æ–°æ ¼å¼: total|size|count:indices|payload
            let parts = data.split("|");
            if (parts.length < 3) return false;

            // æ›´æ–°å…ƒä¿¡æ¯
            if (!totalChunks) {
                totalChunks = parseInt(parts[0]);
                fileSize = parseInt(parts[1]);
            }

            // è§£æç´¢å¼•
            let metaPart = parts[2];
            let [count, indices] = metaPart.split(":");
            let indexList = indices.split(",").map(Number);

            // === å¸§å“ˆå¸Œå»é‡ ===
            let frameHash = getFrameHash(indexList);
            if (processedFrameHashes.has(frameHash)) {
                // å·²å¤„ç†è¿‡ç›¸åŒç´¢å¼•ç»„åˆçš„å¸§ï¼Œè·³è¿‡
                return false;
            }
            // è®°å½•å·²å¤„ç†çš„å¸§å“ˆå¸Œï¼ˆé™åˆ¶é›†åˆå¤§å°é¿å…å†…å­˜è†¨èƒ€ï¼‰
            if (processedFrameHashes.size > 2000) {
                // æ¸…ç†ä¸€åŠçš„æ—§è®°å½•
                let keys = Array.from(processedFrameHashes).slice(0, 1000);
                keys.forEach(k => processedFrameHashes.delete(k));
            }
            processedFrameHashes.add(frameHash);

            // è§£ç  Base45 payload
            let payload = parts.slice(3).join("|"); // å¤„ç† payload ä¸­å¯èƒ½åŒ…å«çš„ |
            let chunk = decodeBase45(payload);

            // === æ­£ç¡®çš„ Fountain ç è§£ç  ===
            let result = tryResolveFrame({ indices: indexList, chunk: chunk });

            if (result === null) {
                // å†—ä½™å¸§
                return false;
            } else if (result.pending) {
                // æš‚å­˜å¾…æ¶ˆå…ƒï¼Œæ·»åŠ åˆ°ç´¢å¼•æ˜ å°„
                let frameIdx = pendingFrames.length;
                let newFrame = { indices: result.indices, chunk: result.chunk };
                pendingFrames.push(newFrame);
                addToPendingIndexMap(result.indices, frameIdx);
                
                // é™åˆ¶ pending é˜Ÿåˆ—é•¿åº¦ï¼Œé¿å…å†…å­˜è†¨èƒ€
                if (pendingFrames.length > 500) {
                    // æ¸…ç†æ—¶éœ€è¦é‡å»ºç´¢å¼•æ˜ å°„
                    let validFrames = pendingFrames.filter(f => f !== null);
                    pendingFrames = validFrames;
                    pendingIndexMap = {};
                    for (let i = 0; i < pendingFrames.length; i++) {
                        addToPendingIndexMap(pendingFrames[i].indices, i);
                    }
                }
                return false;
            } else {
                // ç›´æ¥è§£ç æˆåŠŸ
                processNewChunk(result.index, result.data);
                return true;
            }
        } catch (e) {
            console.error("Decode error:", e);
            return false;
        }
    }

    function reconstructFile() {
        // å¦‚æœæ²¡æ”¶åˆ° META å¸§ï¼Œæç¤ºç”¨æˆ·è¾“å…¥æ–‡ä»¶å
        let downloadName = fileName;
        if (!receivedMeta || !downloadName) {
            let userInput = prompt("æœªæ”¶åˆ°æ–‡ä»¶åä¿¡æ¯ï¼Œè¯·è¾“å…¥ä¿å­˜çš„æ–‡ä»¶å:", "reconstructed_file.bin");
            downloadName = userInput || "reconstructed_file.bin";
        }

        // æŒ‰ç´¢å¼•é¡ºåºé‡ç»„æ–‡ä»¶
        let sortedKeys = Object.keys(decodedChunks).map(Number).sort((a, b) => a - b);
        let chunks = sortedKeys.map(k => decodedChunks[k]);
        let blob = new Blob(chunks, { type: "application/octet-stream" });

        // æˆªæ–­åˆ°å®é™…æ–‡ä»¶å¤§å°
        if (fileSize > 0) {
            blob = blob.slice(0, fileSize);
        }

        let url = URL.createObjectURL(blob);
        let a = document.createElement("a");
        a.href = url;
        a.download = downloadName;
        a.click();
        URL.revokeObjectURL(url);
    }

    // å»é‡ï¼šé¿å…é‡å¤å¤„ç†åŒä¸€å¸§
    let lastFrameData = "";

    function scanFrame() {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let code = jsQR(imageData.data, imageData.width, imageData.height);
        if (code && code.data !== lastFrameData) {
            lastFrameData = code.data;
            decodeFountainChunk(code.data);
            updateProgress();

            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if (totalChunks > 0 && Object.keys(decodedChunks).length >= totalChunks) {
                reconstructFile();
                document.getElementById('status').textContent = "âœ… File reconstructed successfully!";
                return; // åœæ­¢æ‰«æ
            }
        }
        requestAnimationFrame(scanFrame);
    }

    video.addEventListener('play', () => {
        requestAnimationFrame(scanFrame);
    });
</script>
</body>
</html>