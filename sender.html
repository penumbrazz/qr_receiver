<!doctype html>
<html>
  <head>
    <title>TXQR Sender</title>
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
    <style>
      body {
        font-family: sans-serif;
        text-align: center;
        padding: 20px;
      }
      #qr {
        width: 400px;
        height: 400px;
        margin: 20px auto;
      }
      .info {
        margin: 10px 0;
        color: #666;
      }
    </style>
  </head>
  <body>
    <h1>TXQR Sender</h1>
    <input type="file" id="fileInput" /><br /><br />
    <label
      >Chunk Size (bytes):
      <input type="number" id="chunkSize" value="900" /></label
    ><br /><br />
    <canvas id="qr"></canvas>
    <div class="info" id="fileInfo"></div>
    <div class="info" id="streamInfo"></div>

    <script>
      let chunks = [];
      let totalChunks = 0;
      let fileSize = 0;
      let fileName = "";
      let canvas = document.getElementById("qr");
      let ctx = canvas.getContext("2d");
      let streamInterval = null;

      // Base45 编码表 (QR 码 Alphanumeric 字符集)
      const BASE45_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";

      function encodeBase45(uint8array) {
        let result = "";
        for (let i = 0; i < uint8array.length; i += 2) {
          if (i + 1 < uint8array.length) {
            let x = (uint8array[i] << 8) + uint8array[i + 1];
            let e = x % 45;
            x = Math.floor(x / 45);
            let d = x % 45;
            x = Math.floor(x / 45);
            let c = x % 45;
            result += BASE45_CHARS[c] + BASE45_CHARS[d] + BASE45_CHARS[e];
          } else {
            let x = uint8array[i];
            let d = x % 45;
            x = Math.floor(x / 45);
            let c = x % 45;
            result += BASE45_CHARS[c] + BASE45_CHARS[d];
          }
        }
        return result;
      }

      function chunkData(buffer, size) {
        let result = [];
        for (let i = 0; i < buffer.byteLength; i += size) {
          result.push(buffer.slice(i, i + size));
        }
        return result;
      }

      function generateFountainChunk(chunks) {
        // 50% 概率发送单块帧（直接可用，无需解码），其余混合最多3块
        let count =
          Math.random() < 0.5
            ? 1
            : Math.floor(Math.random() * Math.min(3, chunks.length)) + 1;
        let indices = [];
        let xor = new Uint8Array(chunks[0].byteLength).fill(0);

        for (let i = 0; i < count; i++) {
          let idx = Math.floor(Math.random() * chunks.length);
          indices.push(idx);
          let chunk = new Uint8Array(chunks[idx]);
          for (let j = 0; j < chunk.length; j++) {
            xor[j] ^= chunk[j];
          }
        }

        // 新格式: total|size|count:indices|payload (使用 Base45)
        let meta = `${totalChunks}|${fileSize}|${count}:${indices.join(",")}`;
        let payload = encodeBase45(xor);
        return `${meta}|${payload}`;
      }

      // 发送元信息帧
      function generateMetaFrame() {
        // 格式: META|total|size|filename
        let encodedName = encodeURIComponent(fileName);
        return `META|${totalChunks}|${fileSize}|${encodedName}`;
      }

      function startStreaming() {
        let frameCount = 0;
        streamInterval = setInterval(() => {
          let data;
          // 每10帧发送一次元信息
          if (frameCount % 20 === 0) {
            data = generateMetaFrame();
          } else {
            data = generateFountainChunk(chunks);
          }
          frameCount++;

          QRCode.toCanvas(
            canvas,
            data,
            {
              width: 400,
              errorCorrectionLevel: "L",
              margin: 1,
            },
            (err) => {
              if (err) console.error(err);
            },
          );

          document.getElementById("streamInfo").textContent = `Streaming... `;
        }, 50);
      }

      document
        .getElementById("fileInput")
        .addEventListener("change", async (e) => {
          let file = e.target.files[0];
          if (!file) return;

          // 停止之前的流
          if (streamInterval) {
            clearInterval(streamInterval);
            streamInterval = null;
          }

          let chunkSize = parseInt(document.getElementById("chunkSize").value);
          let buffer = await file.arrayBuffer();

          fileSize = buffer.byteLength;
          fileName = file.name;
          chunks = chunkData(buffer, chunkSize);
          totalChunks = chunks.length;

          document.getElementById("fileInfo").textContent =
            `文件: ${fileName} | 大小: ${formatSize(fileSize)} | 分块: ${totalChunks}`;

          startStreaming();
        });

      function formatSize(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + " KB";
        return (bytes / (1024 * 1024)).toFixed(2) + " MB";
      }
    </script>
  </body>
</html>
