<!doctype html>
<html>
  <head>
    <title>TXQR Sender</title>
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      body {
        font-family: sans-serif;
        text-align: center;
        display: flex;
        flex-direction: column;
        padding: 10px;
      }
      .controls {
        flex-shrink: 0;
        padding-bottom: 10px;
      }
      .controls h1 {
        font-size: 1.2em;
        margin-bottom: 8px;
      }
      .controls label {
        font-size: 0.9em;
      }
      #qr-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 0;
      }
      #qr {
        max-width: 100%;
        max-height: 100%;
      }
      .info {
        flex-shrink: 0;
        margin: 5px 0;
        color: #666;
        font-size: 0.85em;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <h1>TXQR Sender</h1>
      <input type="file" id="fileInput" />
      <label
        >Chunk Size:
        <input type="number" id="chunkSize" value="900" /></label>
    </div>
    <div id="qr-container">
      <canvas id="qr"></canvas>
    </div>
    <div class="info" id="fileInfo"></div>
    <div class="info" id="streamInfo"></div>

    <script>
      let chunks = [];
      let totalChunks = 0;
      let fileSize = 0;
      let fileName = "";
      let canvas = document.getElementById("qr");
      let ctx = canvas.getContext("2d");
      let streamInterval = null;
      let currentData = null;

      // 计算二维码最大尺寸
      function getQRSize() {
        const container = document.getElementById("qr-container");
        const rect = container.getBoundingClientRect();
        // 取宽高中较小值，保持正方形，留一点边距
        return Math.min(rect.width, rect.height) - 20;
      }

      // 监听窗口大小变化
      window.addEventListener("resize", () => {
        if (currentData) {
          renderQR(currentData);
        }
      });

      function renderQR(data) {
        currentData = data;
        const size = Math.max(100, getQRSize()); // 最小100px
        QRCode.toCanvas(
          canvas,
          data,
          {
            width: size,
            errorCorrectionLevel: "L",
            margin: 1,
          },
          (err) => {
            if (err) console.error(err);
          },
        );
      }

      // Base45 编码表 (QR 码 Alphanumeric 字符集)
      const BASE45_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";

      function encodeBase45(uint8array) {
        let result = "";
        for (let i = 0; i < uint8array.length; i += 2) {
          if (i + 1 < uint8array.length) {
            let x = (uint8array[i] << 8) + uint8array[i + 1];
            let e = x % 45;
            x = Math.floor(x / 45);
            let d = x % 45;
            x = Math.floor(x / 45);
            let c = x % 45;
            result += BASE45_CHARS[c] + BASE45_CHARS[d] + BASE45_CHARS[e];
          } else {
            let x = uint8array[i];
            let d = x % 45;
            x = Math.floor(x / 45);
            let c = x % 45;
            result += BASE45_CHARS[c] + BASE45_CHARS[d];
          }
        }
        return result;
      }

      function chunkData(buffer, size) {
        let result = [];
        for (let i = 0; i < buffer.byteLength; i += size) {
          result.push(buffer.slice(i, i + size));
        }
        return result;
      }

      function generateFountainChunk(chunks) {
        // 50% 概率发送单块帧（直接可用，无需解码），其余混合最多3块
        let count =
          Math.random() < 0.5
            ? 1
            : Math.floor(Math.random() * Math.min(3, chunks.length)) + 1;
        let indices = [];
        let xor = new Uint8Array(chunks[0].byteLength).fill(0);

        for (let i = 0; i < count; i++) {
          let idx = Math.floor(Math.random() * chunks.length);
          indices.push(idx);
          let chunk = new Uint8Array(chunks[idx]);
          for (let j = 0; j < chunk.length; j++) {
            xor[j] ^= chunk[j];
          }
        }

        // 新格式: total|size|count:indices|payload (使用 Base45)
        let meta = `${totalChunks}|${fileSize}|${count}:${indices.join(",")}`;
        let payload = encodeBase45(xor);
        return `${meta}|${payload}`;
      }

      // 发送元信息帧
      function generateMetaFrame() {
        // 格式: META|total|size|filename
        let encodedName = encodeURIComponent(fileName);
        return `META|${totalChunks}|${fileSize}|${encodedName}`;
      }

      function startStreaming() {
        let frameCount = 0;
        streamInterval = setInterval(() => {
          let data;
          // 每10帧发送一次元信息
          if (frameCount % 10 === 0) {
            data = generateMetaFrame();
          } else {
            data = generateFountainChunk(chunks);
          }
          frameCount++;

          renderQR(data);

          document.getElementById("streamInfo").textContent = `Streaming... `;
        }, 50);
      }

      document
        .getElementById("fileInput")
        .addEventListener("change", async (e) => {
          let file = e.target.files[0];
          if (!file) return;

          // 停止之前的流
          if (streamInterval) {
            clearInterval(streamInterval);
            streamInterval = null;
          }

          let chunkSize = parseInt(document.getElementById("chunkSize").value);
          let buffer = await file.arrayBuffer();

          fileSize = buffer.byteLength;
          fileName = file.name;
          chunks = chunkData(buffer, chunkSize);
          totalChunks = chunks.length;

          document.getElementById("fileInfo").textContent =
            `文件: ${fileName} | 大小: ${formatSize(fileSize)} | 分块: ${totalChunks}`;

          startStreaming();
        });

      function formatSize(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + " KB";
        return (bytes / (1024 * 1024)).toFixed(2) + " MB";
      }
    </script>
  </body>
</html>
